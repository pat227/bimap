Implementation of a bi-map; see com.google.guava.bimap. Implemented
here for re-use using two maps under the hood. Also supports multi-bi-map,
in which a key is mapped to multiple values as in a multi-map and
the inverse view is supported as well under which any one of the values
will provide the key.

The parameterized class holds two mutable maps. Each method ensures us
that both maps are updated properly, alleviating the user or client code
from performing the correct operations on both maps when interacting
with either one of them.

The types of the maps are parameterized as follows: 
('a, 'b, 'c) Core.Map.t 
('b, 'a, 'd) Core.Map.t
This allows a forward map and a reverse map to be defined easily. An
example would be:
(Core.String.t, Core.Int.t, Core.String.Comparator.t) Core.Map.t
(Core.Int, Core.String.t, Core.Int.t.Comparator.t) Core.Map.t

NOTE
If 'b in the parameterized class is a list of some type, then the keys in the
reverse map are constrained to be of type 'b (a list of some type). And unlike
working with Core.Map directly, we cannot just decide to invoke add_multi upon
a map that until now has never held lists as values; the paramterized type
constraints of the class require 'b  to be a stand-in for either a list of
some type or a type (that is not a list of some type).

Which is dissapointing b/c the reverse of a multi-map should not be a map
whose keys are lists. It would be better if we could make the inverse or
reverse map of a multi_map merely a map from keys to values where the keys
are not lists. So if a multi-map stored under the key 1 the value ["one","uno"]
then it would be better if we could make the reverse map store under the
key "one" the value 1 and under the key "uno" the value 1 again. But how
to express that with this type system?